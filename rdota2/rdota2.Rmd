---
title: "十行代码预测插旗西雅图"
author: "CJ"
date: "May 16, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 背景故事

我错了，我承认我是标题党，怎么可能用十行代码完成**信仰2 ~~Dota2~~ 比赛数据的抓取, 清洗与预测建模呢**。
不过为了发扬继承郎大为“十行代码”系列的优良传统，我决定沿用这个名字，希望能把品牌做大做强，走出亚洲，面向世界。。。

事情的起因是这样的：上周与同为信仰粉的大为接上头之后，被安利了一个叫 RDota2 的 R pacakge。
这个工具包使用 Steam API，可以让 R 直接提取有关 Dota2 的各种数据：除了每一场游戏的具体信息，还可以得到英雄，物品，战队，和联赛的资料。
所以我就萌生了用这个 API 提取一批比赛数据，然后建模预测比赛输赢的想法。结果还是相当有趣的，且听我慢慢道来。
不过在此之前，我想先为对这个问题感兴趣但不知道什么是 Dota2 的同学，简单介绍一下这款游戏。

Dota2 来源于暴雪魔兽争霸的一张自定义地图，又叫 RPG 图，就是由地图开发者在魔兽争霸这个游戏之上自己创建了一种玩法。
这张地图的名字就叫做 Dota，Defense of the Ancient，被视为当下十分流行的MOBA类游戏的鼻祖。
MOBA游戏的特点是，两队人马以摧毁对方大本营为目的互相厮杀，五个玩家组成一队，每个玩家从各具特色的一百多个英雄中选出一个，互相支援互相配合。一场比赛的用时大概在半小时到一小时之间，当然也有十分钟的短局，或者三四个小时的膀胱局。
Dota 的首个版本于03年由开发者 Eul 发布，中间更换好几次开发者之后，由传奇的 Icefrog 冰蛙于05年开始接手开发至今，开启了一个传奇的时代。
我是从冰蛙接手后的6.41版本开始接触 Dota 的，不要问我为什么能把版本号记得那么清楚，
当一件事不是为了生计，而是完全出于喜爱而持续做了十年的时候，就成为了一种信仰（庄严脸）。

当然很少有游戏能连续流行十几年。所以 Dota 的经久不衰要感谢 Dota2 的一波续命。09年，拥有全球最大在线游戏销售平台 Steam 的游戏公司 Valve 看中了 Dota 的巨大潜力，把冰蛙招入麾下着手开发独立的一款游戏 Dota2，使其摆脱魔兽争霸一张地图的身份。
为此还引发了反应慢半拍的暴雪和 Valve 之间的版权纠纷。
Dota2 所有理念和设计完全照搬 Dota，但因为能独立于魔兽争霸之外，新的引擎给 Dota2 更绚丽的画面，更流畅的手感，以及游戏本身更高的自由度。
但是 Dota2 在10年刚推出的时候，因为本身的完成度很低，和 Dota 本体的热度还在如火如荼中等原因，基本上没人能够或者愿意玩。
直到11年 Valve 在德国科隆游戏展上举办了 Dota2 的国际竞标赛 The International (TI)，Dota2 才成功展示了自己的存在。
Valve 的这一手“千金买马骨”玩得实在溜，要知道当时即使在电竞最发达的欧洲，各大比赛的奖金基本上就几千欧，
突然石破天惊来一个总奖金160万美元，冠军100万美元，这能不让世界各地的网瘾少年们目瞪口呆吗。
如今的各位职业大佬们回忆起当时情景，无一例外得表示他们的第一反应都是，这公司是骗子吧。
然后 TI 的传统就延续了下来，除了 TI1，之后的5届都在 Valve 总部西雅图举办，其中中国战队拿了 TI2，TI4，和 TI6的冠军，
去年 TI6 的总奖金为2000万美元。不论从哪个角度，荣誉还是犒赏，把红旗插在西雅图都是每个中国战队的终极梦想。

现在的我看 Dota 比赛比自己玩更有乐趣，主要因素还是水平稀烂吧。不过关于 Dota 最深刻的记忆也是看比赛：
清楚记得看 TI2 中国战队与国外战队的决赛直播时，基友一脸便秘的紧张神情；还有和另一半和基友去 TI5 现场时感受到的盛况空前。
好了，人长大了回忆起来就没完，下面进入正题：首先聊聊工具包 RDota2 的使用，
然后写如何从 API 抓取到的数据里提取有用的信息用来建模，第三部分就是建模的步骤和结果了。



## RDota2 简介

在使用 RDota2 之前，我们需要到 [Steam 网站](https://steamcommunity.com/login/home/?goto=%2Fdev%2Fapikey) 申请 Steam API 的 Key。
有 Steam 账号的话马上就能得到。在加载 RDota2 之后，只需要设定一次 Key，就能愉快得通过 API 提取数据了。

```{r, message=FALSE, warning=FALSE}
library(RDota2)
API_key = readRDS("API_key")
key_actions(action = 'register_key', value = API_key)
```

当然，更安全的方式是把 Key 存在操作系统的环境变量中，以后引用这个变量即可，
具体流程可以参考 [这里](https://cran.r-project.org/web/packages/RDota2/vignettes/RDota2.html)。


### get_xxx 系列函数

RDota2 通过各种 get 函数连接 API 抓取数据。
除了提取详细比赛信息的函数 `get_match_details()` 和 `get_match_history_by_sequence_num()` 之外






## 数据处理



``` {r, message=FALSE, warning=FALSE}
library(data.table)
setwd("D:/Workspace/Tutorial/rdota2/data")
mvec = readRDS("mvec")


dt = list()
MRD = list()
for (i in 1:5) {
  mid.a = mvec[i]
  dt[[i]] = readRDS(paste0("RDS",mid.a))
  dt[[i]] = dt[[i]][order(dt[[i]]$mid),]
  dt[[i]] = dt[[i]][dt[[i]]$duration>=900,]
  
  dt.m = reshape2::melt(dt[[i]][,c("mid","R1","R2","R3","R4","R5"),with=F],id="mid")
  mx = as.matrix(table(dt.m$mid, dt.m$value))
  colnames(mx) = paste0("R",colnames(mx))
  
  MRD[[i]] = mx[order(rownames(mx)),]
  
  dt.m = reshape2::melt(dt[[i]][,c("mid","D1","D2","D3","D4","D5"),with=F],id="mid")
  mx = as.matrix(table(dt.m$mid, dt.m$value))
  colnames(mx) = paste0("D",colnames(mx))
  
  gtype = rep(NA, dim(dt[[i]])[1])
  gtype[dt[[i]]$lobby==1&dt[[i]]$gmode==2] = "PRO"
  gtype[dt[[i]]$lobby==7&dt[[i]]$gmode==2] = "RCM"
  gtype[dt[[i]]$lobby==7&dt[[i]]$gmode==22] = "RAP"
  gtype[dt[[i]]$lobby==7&dt[[i]]$gmode==3] = "RRD"
  gtype = model.matrix(~.-1,data=data.frame(gtype))
  
  MRD[[i]] = cbind(MRD[[i]], mx[order(rownames(mx)),])
  MRD[[i]] = cbind(MRD[[i]], gtype)
  MRD[[i]] = cbind(MRD[[i]], dt[[i]]$duration, as.integer(dt[[i]]$Rwin))
  colnames(MRD[[i]])[(dim(MRD[[i]])[2]-1):(dim(MRD[[i]])[2])] = c("duration","Rwin")
  
  print(i)
}

mrd = rbind(MRD[[1]],MRD[[2]],MRD[[4]],MRD[[5]])
```





## 附录

```{r, eval=FALSE}
library(data.table)
library(RDota2)
setwd("D:/Workspace/Tutorial/rdota2/data")
key_actions(action='register_key', value='XXXXXXXXXXXX')
mvec = readRDS("mvec")


################ Input ################
# match_id to get started
mid.a <- mvec[7]
# number of records to be pulled
nnn <- 1000
# number of requested matches per pull
rrr <- 10
#######################################


M.a = get_match_details(match_id=mid.a)$content
sid.a = M.a$match_seq_num
stime.a = as.POSIXct(M.a$start_time, origin = '1970-01-01', tz = 'GMT')
sid = sid.a



over.time = Sys.time()
for (p in 1:100) {
  
  
  # row index
  i = 1
  # iteration number
  iter = 1
  
  
  ###### info of initial match ######
  dt = data.table(mid=rep(NA_integer_,nnn), 
                  lobby=rep(NA_integer_,nnn),
                  gmode=rep(NA_integer_,nnn),
                  leagueid=rep(NA_integer_,nnn),
                  R1=rep(NA_integer_,nnn), R2=rep(NA_integer_,nnn),
                  R3=rep(NA_integer_,nnn), R4=rep(NA_integer_,nnn), R5=rep(NA_integer_,nnn),
                  D1=rep(NA_integer_,nnn), D2=rep(NA_integer_,nnn),
                  D3=rep(NA_integer_,nnn), D4=rep(NA_integer_,nnn), D5=rep(NA_integer_,nnn),
                  st=rep(NA_integer_,nnn), 
                  duration=rep(NA_integer_,nnn), 
                  Rscore=rep(NA_integer_,nnn), Dscore=rep(NA_integer_,nnn), 
                  Rwin=rep(NA,nnn))
  
  
  ###### pull matches ######
  start.time = Sys.time()
  while (i <= nnn) {
    tryCatch({
      M <- get_match_history_by_sequence_num(matches_requested=rrr, start_at_match_seq_num=sid)$content
      for (r in 1:rrr) {
        ltype = M$matches[[r]]$lobby_type
        gmode = M$matches[[r]]$game_mode
        human = M$matches[[r]]$human_players
        if ((ltype==1&gmode==2&human==10) | (ltype==7&human==10)) {
          dt$mid[i] = M$matches[[r]]$match_id
          dt$lobby[i] = ltype
          dt$gmode[i] = gmode
          dt$leagueid[i] = M$matches[[r]]$leagueid
          dt$R1[i] = M$matches[[r]][[1]][[1]]$hero_id
          dt$R2[i] = M$matches[[r]][[1]][[2]]$hero_id
          dt$R3[i] = M$matches[[r]][[1]][[3]]$hero_id
          dt$R4[i] = M$matches[[r]][[1]][[4]]$hero_id
          dt$R5[i] = M$matches[[r]][[1]][[5]]$hero_id
          dt$D1[i] = M$matches[[r]][[1]][[6]]$hero_id
          dt$D2[i] = M$matches[[r]][[1]][[7]]$hero_id
          dt$D3[i] = M$matches[[r]][[1]][[8]]$hero_id
          dt$D4[i] = M$matches[[r]][[1]][[9]]$hero_id
          dt$D5[i] = M$matches[[r]][[1]][[10]]$hero_id
          dt$st[i] = M$matches[[r]]$start_time
          dt$duration[i] = M$matches[[r]]$duration
          dt$Rscore[i] = M$matches[[r]]$radiant_score
          dt$Dscore[i] = M$matches[[r]]$dire_score
          dt$Rwin[i] = M$matches[[r]]$radiant_win
        }
        i = i+1
      }
      cat("--- ", iter*rrr,"/", nnn, " ---\n", sep="")
      iter = iter + 1
      sid = M$matches[[rrr]]$match_seq_num + 1
      #Sys.sleep(1)
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
  }
  print(Sys.time() - start.time)
  
  
  ###### save data ######
  dt = dt[!is.na(dt$mid),]
  saveRDS(dt, paste0("M",mid.a,"/f",p))
  sid = sid + 1
  cat("++++++++++++", p, "++++++++++++\n")
  
}
print(Sys.time() - over.time)


################ Input ################
# match_id to get started
mid.a <- mvec[6]
# number of RDS files in each folder
fff <- 100
#######################################

data <- list()
for (i in 1:fff) {
  data[[i]] <- readRDS(paste0("M",mid.a,"/f",i))
  print(i)
}
dt = rbindlist(data)

saveRDS(dt, paste0("RDS",mid.a))

```




