---
title: "十行代码预测插旗西雅图"
author: "CJ"
date: "May 16, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 背景故事

我错了，我承认我是标题党，怎么可能用十行代码完成**信仰2 ~~Dota2~~ 比赛数据的抓取, 清洗与预测建模呢**。
不过为了发扬继承郎大为“十行代码”系列的优良传统，我决定沿用这个名字，希望能把品牌做大做强，走出亚洲，面向世界。。。

事情的起因是这样的：上周与同为信仰粉的大为接上头之后，被安利了一个叫 RDota2 的 R pacakge。
这个工具包使用 Steam API，可以让 R 直接提取有关 Dota2 的各种数据：除了每一场游戏的具体信息，还可以得到英雄，物品，战队，和联赛的资料。
所以我就萌生了用这个 API 提取一批比赛数据，然后建模预测比赛输赢的想法。结果还是相当有趣的，且听我慢慢道来。
不过在此之前，我想先为对这个问题感兴趣但不知道什么是 Dota2 的同学，简单介绍一下这款游戏。

Dota2 来源于暴雪魔兽争霸的一张自定义地图，又叫 RPG 图，就是由地图开发者在魔兽争霸这个游戏之上自己创建了一种玩法。
这张地图的名字就叫做 Dota，Defense of the Ancient，被视为当下十分流行的MOBA类游戏的鼻祖。
MOBA游戏的特点是，两队人马以摧毁对方大本营为目的互相厮杀，五个玩家组成一队，每个玩家从各具特色的一百多个英雄中选出一个，互相支援互相配合。
一场比赛的用时大概在半小时到一小时之间，当然也有十分钟的短局，或者三四个小时的膀胱局。
Dota 的首个版本于03年由开发者 Eul 发布，中间更换好几次开发者之后，由传奇的 Icefrog 冰蛙于05年开始接手开发至今，开启了一个传奇的时代。
我是从冰蛙接手后的6.41版本开始接触 Dota 的，不要问我为什么能把版本号记得那么清楚，
当一件事不是为了生计，而是完全出于喜爱而持续做了十年的时候，就成为了一种信仰（庄严脸）。

当然很少有游戏能连续流行十几年。所以 Dota 的经久不衰要感谢 Dota2 的一波续命。
09年，拥有全球最大在线游戏销售平台 Steam 的游戏公司 Valve 看中了 Dota 的巨大潜力，把冰蛙招入麾下着手开发独立的一款游戏 Dota2，
使其摆脱魔兽争霸一张地图的身份。
为此还引发了反应慢半拍的暴雪和 Valve 之间的版权纠纷。
Dota2 所有理念和设计完全照搬 Dota，但因为能独立于魔兽争霸之外，新的引擎给 Dota2 更绚丽的画面，更流畅的手感，以及游戏本身更高的自由度。
但是 Dota2 在10年刚推出的时候，因为本身的完成度很低，和 Dota 本体的热度还在如火如荼中等原因，基本上没人能够或者愿意玩。
直到11年 Valve 在德国科隆游戏展上举办了 Dota2 的国际竞标赛 The International (TI)，Dota2 才成功展示了自己的存在。
Valve 的这一手“千金买马骨”玩得实在溜，要知道当时即使在电竞最发达的欧洲，各大比赛的奖金基本上就几千欧，
突然石破天惊来一个总奖金160万美元，冠军100万美元，这能不让世界各地的网瘾少年们目瞪口呆吗。
如今的各位职业大佬们回忆起当时情景，无一例外得表示他们的第一反应都是，这公司是骗子吧。
然后 TI 的传统就延续了下来，除了 TI1，之后的5届都在 Valve 总部西雅图举办，其中中国战队拿了 TI2，TI4，和 TI6的冠军，
去年 TI6 的总奖金为2000万美元。不论从哪个角度，荣誉还是犒赏，把红旗插在西雅图都是每个中国战队的终极梦想。

现在的我看 Dota 比赛比自己玩更有乐趣，主要因素还是水平稀烂吧。不过关于 Dota 最深刻的记忆也是看比赛：
清楚记得看 TI2 中国战队与国外战队的决赛直播时，基友一脸便秘的紧张神情；还有和另一半和基友去 TI5 现场时感受到的盛况空前。
好了，人长大了回忆起来就没完，下面进入正题：首先聊聊工具包 RDota2 的使用，
然后写如何从 API 抓取到的数据里提取有用的信息用来建模，第三部分就是建模的步骤和结果了。



## RDota2 简介

在使用 RDota2 之前，我们需要到 [Steam 网站](https://steamcommunity.com/login/home/?goto=%2Fdev%2Fapikey) 申请 Steam API 的 Key。
有 Steam 账号的话马上就能得到。加载 RDota2 之后，只需要设定一次 Key，就能愉快得通过 API 提取数据了。

```{r, message=FALSE, warning=FALSE}
library(RDota2)
API_key = readRDS("API_key")
key_actions(action = 'register_key', value = API_key)
```

当然，更安全的方式是把 Key 存在操作系统的环境变量中，以后引用这个变量即可，
具体流程可以参考 [这里](https://cran.r-project.org/web/packages/RDota2/vignettes/RDota2.html)。


### get_xxx 系列函数

RDota2 通过各种 get 函数连接 Steam API 抓取数据。
所有的 get 函数的返回值都包含三个元素：

* url: 该次 API 请求的链接，可以把这个链接复制到浏览器的地址栏，回车得到相应的返回值
* content: 该次 API 请求的具体返回值，因为用 web 返回数据的格式是json格式（复制到浏览器回车），在 R 里面 content 的形式是一个层叠列表
* response：该次 API 请求在 Steam 服务器里面的处理信息

除了提取详细比赛信息的函数 `get_match_details()` 和 `get_match_history_by_sequence_num()` 之外，这两个函数会在后面具体介绍，
还有以下的函数提取关于一般比赛和职业联赛的信息：

* `get_event_stats_for_account(eventid, accountid)`：返回账号 `accountid` 在一般联赛 `eventid` 里的记录
* `get_league_listing()`: 返回所有联赛的信息
* `get_live_league_games()`: 返回正在进行中的联赛以及选手信息
* `get_scheduled_league_games()`: 返回已安排的联赛信息
* `get_team_info_by_team_id(start_at_team_id, teams_requested)`: 从 `start_at_team_id` 开始提取 `teams_requested` 个职业战队的信息
* `get_top_live_game()`: 返回正在进行中的高水平一般比赛和职业联赛，返回值里面有双方的平均 MMR（战斗力），这也是整个 API 里唯一关联 MMR 的函数
* `get_tournament_player_stats(account_id)`: 返回账号 `account_id` 在国际锦标赛 TI 里的记录
* `get_tournament_prize_pool()`: 返回国际锦标赛 TI 奖金池状态

以下函数可以提取其他的游戏信息：

* `get_game_items(language)`: 返回所有游戏物品的 data.frame，指定 `language` 还可以得到物品在这种语言下的名称
* `get_heroes(language)`: 返回所有 Dota 英雄的 data.frame，指定 `language` 还可以得到英雄在这种语言下的名称
* `get_item_icon_path(iconname, icontype)`: 指定物品名称 `iconname` 和类型 `icontype`（0=常规，1=大图，3=游戏内），返回物品图标 CDN 地址
* `get_rarities(language)`: 这个是<span style="color:red">重点</span>，返回 Dota2 商店内饰品和皮肤的掉落率


### get_match_details 和  get_match_history_by_sequence_num

使用 `get_match_details(match_id)` 返回比赛详细信息时需要指定该场比赛的 ID，也就是所谓的录像编号。一般比赛会返回一个长度是23的列表，
第1个元素包含了10名玩家的具体游戏信息，它本身也是一个复杂列表，除此之外，其他的元素都是一元的。它们包括：

* radiant_win: 天辉是否获胜，1=是 0=否
* duration: 比赛总时长，以秒计
* pre_game_duration: 正式比赛前准备时长
* start_time: 游戏开始时间，Unix 时间形式，下面例子里有时间转化方法
* match_id: 比赛 ID
* match_seq_num: 比赛序列号，该编号按比赛开始时间呈次序排列
* tower_status_radiant: 天辉防御塔状态，具体参考 [此处](https://dota2api.readthedocs.io/en/latest/responses.html#towers-and-barracks)
* tower_status_dire: 夜魇防御塔状态，具体同上
* barracks_status_radiant: 天辉兵营状态，具体参考 [此处](https://dota2api.readthedocs.io/en/latest/responses.html#towers-and-barracks)
* barracks_status_dire: 夜魇兵营塔状态，具体同上
* first_blood_time: 一血时间
* lobby_type: 游戏大厅，具体参考 [此处](https://dota2api.readthedocs.io/en/latest/responses.html#lobby-type)，常见的有：
  + 0=常规比赛
  + 2=练习，但所有职业比赛都在这一类里
  + 7=排位赛，就是所谓的天梯
* human_players: 非机器人的玩家数量
* leagueid: 联赛 ID，0=一般比赛
* positive_votes: “喜欢”投票
* negative_votes: “不喜欢”投票
* game_mode: 游戏模式，具体参考 [此处](https://dota2api.readthedocs.io/en/latest/responses.html#game-mode)，常见的有：
  + 1=全阵营
  + 2=队长模式
  + 3=随机征召
  + 4=
  + 5=全随机
  + 21=中路1对1
  + 22=排位赛全阵营
* flags: 未知
* engine: 0=source1 1=source 2
* radiant_score: 天辉击杀数
* dire_score: 夜魇击杀数

```{r, message=FALSE, warning=FALSE}
match.normal <- get_match_details(match_id = 3170508667)$content
unlist(match.normal[-1])
as.POSIXct(match.normal$start_time, origin = '1970-01-01', tz = 'GMT')
```

职业联赛返回列表更长，除了上面的这些信息外，还有两支对决战队的信息，以及列表第34个元素包含的 Ban/Pick 详细信息。
这里取4月亚洲锦标赛的一场决赛为例。祝贺B神！

```{r, message=FALSE, warning=FALSE}
match.league <- get_match_details(match_id = 3097027819)$content
unlist(match.normal[-c(1, 34)])
```

玩家列表（返回值的第一个元素）包含10个元素，对应10个玩家，前5个是天辉，后5个是夜魇。下面是某一个玩家的具体信息，包括所选英雄，物品栏，击杀/死亡/助攻，正反补，金钱经验每分钟，造成伤害/治疗，技能升级等等。

```{r, message=FALSE, warning=FALSE}
str(match.league$players[[5]])
```

值得注意的是，`player_slot` 这一栏在设定上是可以区分1到5号位的，但是实际中并没有用到，还是0到4为天辉，128到132为夜魇。

```
┌─────────────── 0=天辉 1=夜魇
│ ┌─┬─┬─┬─────── 没用
│ │ │ │ │ ┌─┬─┬─ 队伍中的1到5号位 (0-4)
0 0 0 0 0 0 0 0
```

以上就是 `get_match_details()` 函数的所有返回值。
`get_match_history_by_sequence_num(start_at_match_seq_num, matches_requested)` 函数的返回值是一模一样的形式，
唯一的不同就是这个函数可以返回多场比赛的详细信息，从 `start_at_match_seq_num` 开始往后返回 `matches_requested` 场比赛，
注意这里必须输入比赛序列号 match_seq_num，该编号按比赛开始时间呈次序排列。另外1次请求最多能返回100场比赛的信息。

```{r, message=FALSE, warning=FALSE}
match.multi <- get_match_history_by_sequence_num(start_at_match_seq_num=2704563366， matches_requested=10)$content
c(match.multi$maches[[1]]$match_id, match.multi$maches[[10]]$match_id)
```

其实还有一个 get 函数 `get_match_history()` 可以通过输入不同的参数例如 game_mode 来筛选返回的比赛。
但当我测试时，有些输入参数并没有正确的筛选比赛，而且返回的比赛信息太简略，缺少比赛胜负信息，我就没有用这个函数提取比赛数据。



## 数据处理



``` {r, message=FALSE, warning=FALSE}
library(data.table)
setwd("D:/Workspace/Tutorial/rdota2/data")
mvec = readRDS("mvec")


dt = list()
MRD = list()
for (i in 1:5) {
  mid.a = mvec[i]
  dt[[i]] = readRDS(paste0("RDS",mid.a))
  dt[[i]] = dt[[i]][order(dt[[i]]$mid),]
  dt[[i]] = dt[[i]][dt[[i]]$duration>=900,]
  
  dt.m = reshape2::melt(dt[[i]][,c("mid","R1","R2","R3","R4","R5"),with=F],id="mid")
  mx = as.matrix(table(dt.m$mid, dt.m$value))
  colnames(mx) = paste0("R",colnames(mx))
  
  MRD[[i]] = mx[order(rownames(mx)),]
  
  dt.m = reshape2::melt(dt[[i]][,c("mid","D1","D2","D3","D4","D5"),with=F],id="mid")
  mx = as.matrix(table(dt.m$mid, dt.m$value))
  colnames(mx) = paste0("D",colnames(mx))
  
  gtype = rep(NA, dim(dt[[i]])[1])
  gtype[dt[[i]]$lobby==1&dt[[i]]$gmode==2] = "PRO"
  gtype[dt[[i]]$lobby==7&dt[[i]]$gmode==2] = "RCM"
  gtype[dt[[i]]$lobby==7&dt[[i]]$gmode==22] = "RAP"
  gtype[dt[[i]]$lobby==7&dt[[i]]$gmode==3] = "RRD"
  gtype = model.matrix(~.-1,data=data.frame(gtype))
  
  MRD[[i]] = cbind(MRD[[i]], mx[order(rownames(mx)),])
  MRD[[i]] = cbind(MRD[[i]], gtype)
  MRD[[i]] = cbind(MRD[[i]], dt[[i]]$duration, as.integer(dt[[i]]$Rwin))
  colnames(MRD[[i]])[(dim(MRD[[i]])[2]-1):(dim(MRD[[i]])[2])] = c("duration","Rwin")
  
  print(i)
}

mrd = rbind(MRD[[1]],MRD[[2]],MRD[[4]],MRD[[5]])
```


## 建模及结果


## 附录

```{r, eval=FALSE}
library(data.table)
library(RDota2)
setwd("D:/Workspace/Tutorial/rdota2/data")
key_actions(action='register_key', value='XXXXXXXXXXXX')
mvec = readRDS("mvec")


################ Input ################
# match_id to get started
mid.a <- mvec[7]
# number of records to be pulled
nnn <- 1000
# number of requested matches per pull
rrr <- 10
#######################################

ifelse(!dir.exists(paste0("M",mid.a)), dir.create(paste0("M",mid.a)), FALSE)

M.a = get_match_details(match_id=mid.a)$content
sid.a = M.a$match_seq_num
stime.a = as.POSIXct(M.a$start_time, origin = '1970-01-01', tz = 'GMT')
sid = sid.a



over.time = Sys.time()
for (p in 1:100) {
  
  
  # row index
  i = 1
  # iteration number
  iter = 1
  
  
  ###### info of initial match ######
  dt = data.table(mid=rep(NA_integer_,nnn), 
                  lobby=rep(NA_integer_,nnn),
                  gmode=rep(NA_integer_,nnn),
                  leagueid=rep(NA_integer_,nnn),
                  R1=rep(NA_integer_,nnn), R2=rep(NA_integer_,nnn),
                  R3=rep(NA_integer_,nnn), R4=rep(NA_integer_,nnn), R5=rep(NA_integer_,nnn),
                  D1=rep(NA_integer_,nnn), D2=rep(NA_integer_,nnn),
                  D3=rep(NA_integer_,nnn), D4=rep(NA_integer_,nnn), D5=rep(NA_integer_,nnn),
                  st=rep(NA_integer_,nnn), 
                  duration=rep(NA_integer_,nnn), 
                  Rscore=rep(NA_integer_,nnn), Dscore=rep(NA_integer_,nnn), 
                  Rwin=rep(NA,nnn))
  
  
  ###### pull matches ######
  start.time = Sys.time()
  while (i <= nnn) {
    tryCatch({
      M <- get_match_history_by_sequence_num(matches_requested=rrr, start_at_match_seq_num=sid)$content
      for (r in 1:rrr) {
        ltype = M$matches[[r]]$lobby_type
        gmode = M$matches[[r]]$game_mode
        human = M$matches[[r]]$human_players
        if ((ltype==1&gmode==2&human==10) | (ltype==7&human==10)) {
          dt$mid[i] = M$matches[[r]]$match_id
          dt$lobby[i] = ltype
          dt$gmode[i] = gmode
          dt$leagueid[i] = M$matches[[r]]$leagueid
          dt$R1[i] = M$matches[[r]][[1]][[1]]$hero_id
          dt$R2[i] = M$matches[[r]][[1]][[2]]$hero_id
          dt$R3[i] = M$matches[[r]][[1]][[3]]$hero_id
          dt$R4[i] = M$matches[[r]][[1]][[4]]$hero_id
          dt$R5[i] = M$matches[[r]][[1]][[5]]$hero_id
          dt$D1[i] = M$matches[[r]][[1]][[6]]$hero_id
          dt$D2[i] = M$matches[[r]][[1]][[7]]$hero_id
          dt$D3[i] = M$matches[[r]][[1]][[8]]$hero_id
          dt$D4[i] = M$matches[[r]][[1]][[9]]$hero_id
          dt$D5[i] = M$matches[[r]][[1]][[10]]$hero_id
          dt$st[i] = M$matches[[r]]$start_time
          dt$duration[i] = M$matches[[r]]$duration
          dt$Rscore[i] = M$matches[[r]]$radiant_score
          dt$Dscore[i] = M$matches[[r]]$dire_score
          dt$Rwin[i] = M$matches[[r]]$radiant_win
        }
        i = i+1
      }
      cat("--- ", iter*rrr,"/", nnn, " ---\n", sep="")
      iter = iter + 1
      sid = M$matches[[rrr]]$match_seq_num + 1
      #Sys.sleep(1)
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
  }
  print(Sys.time() - start.time)
  
  
  ###### save data ######
  dt = dt[!is.na(dt$mid),]
  saveRDS(dt, paste0("M",mid.a,"/f",p))
  sid = sid + 1
  cat("++++++++++++", p, "++++++++++++\n")
  
}
print(Sys.time() - over.time)


################ Input ################
# match_id to get started
mid.a <- mvec[6]
# number of RDS files in each folder
fff <- 100
#######################################

data <- list()
for (i in 1:fff) {
  data[[i]] <- readRDS(paste0("M",mid.a,"/f",i))
  print(i)
}
dt = rbindlist(data)

saveRDS(dt, paste0("RDS",mid.a))

```




